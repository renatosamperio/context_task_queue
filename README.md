# Context-based Task Queue
A context-based task queue implementation of for creating stand-along processes with an specific purpose while having the ability to communicate withing other processes in their or other context.

Communcication is implemented using ZMQ forward devices in a TCP/IP stack. 

* __Context__: A context is a set of services typically defined by processes but also available in tis thread version. A context has a transaction identifier and it also identifies itsoperations to its services. Additionally, any context communication is generated by using messages over the *context* topic. 

* __Task service__: A task service is configured in an XML file. A service requires of an identifer, topic for publishing, an instance type and a service type (process or thread). The instance type encapsulates a specific functionality and can be loaded dynamically. In addition, services can interact among each other by using a TCP/IP based interprocess communication along a *process* topic.

* __Message__: A message is a JSON formmatted data structure for containing service ouput or input. A message is conformed by a header and a content section. Each message is generated by a service andpublished in a topic depending on the communication destination and functionality.

* __Context managing__: The services and context can communicate by using an endpoint and port. The group of services in a context can be started, stopped or restarted. In addition, services in a context can be executed in a event-based state machine by using state transitions: *on_exit*, *on_fail* and *on_start*.
* __Context managing__: The services and context can communicate by using an endpoint and port. The group of services in a context can be started, stopped or restarted. In addition, services in a context can be executed in a event-based state machine by using state transitions: *on_exit*, *on_fail* and *on_start*.

# Tutorial
## Service creation
To create a context service it is required to do the following steps:
1. Add a service directory
2. Provide a ```__init__.py```
3. Generate a ```Service[NAME].py``` stub file
4. Generate a strategy file stub
5. Update configuration ```XML``` file

In this tutorial we are using the ```create_service.py``` command that is contained in the ```Tools``` section. This command allow us to run all steps for generating a context service.

To create a single process environment for a service called __EchoAction__, use the following command:

    $ python create_service.py     
        --service_path='/abs/unix/path/'
		--task_service='EchoAction' 
		--task_file='task_file_name 
		--task_class='EchoShouting' 
		--task_desc='An echo action is for shouting the time after counting 10s' 
		--context_name='EchoAction' 
		--service_name='echo_action' 
		--server_ip='127.0.0.1' 
		--sub_port='5556' 
		--pub_port='5557' 
		--task_id='ts_100' 
		--device_action='shout'

Afterwards, configuration file can be found in:

    $ ls Conf/
    Context-EchoAction.xml  ...

And the service files can be found in:

    $ ls Services/
    EchoAction  ...
    
    $ ls Services/EchoAction/
    EchoAction.py  __init__.py  ServiceEchoAction.py
    
## Service configuration
The ```create_service.py``` command requires the following parameters:
* Service configuration location
  * __Service path__ is the absolute root path where context services are located
* Service generation stub variables
  * __Service instance type__ is the type of created service as defined in task 
  service parameters as 'instance' in the configuration file.
  * __Task file name__ is for defining specific operations from task class. It will be imported from created directory and used to instance a 
  task class.
  * __Service class name__ is the name of the autogenerated task class. It should have the logic for   producing a service. It is called by the service and imported by file name.
  * __Task Description__ it is required for logging and identifying task operations.
* Service XML configuration options
  * __Context name__ is the logging context name. It is used in 'TaskLogName' in the configuration file.
  * __Service name__ defines a service name for the identifying service process messages. It is called in process configuration configuration file.
  * __Service endpoint__ states an IP address of server endpoint. It is used in 'FrontEndEndpoint' and 'BackendEndpoint' in the configuration file.
  * __Frontend port__ is used as frontend port for subscriber and back end binding ports. It is used in 'FrontEndEndpoint'
  and 'BackendBind' in the configuration file.
  * __Backend port__ is used as backend port for subscriber and front end binding ports. It is used in 'BackendEndpoint' and 'FrontBind' in the configuration file.
  * __Task ID__ defines a task service ID identifier. It is used as parameter 'id' in 'TaskService' label in the configuration file.
  * __Device action__ is the task device action used for message identification. It is called as parameter 'device_action' of the content configuration of the task service in the configuration file.
  
All described parameters are required when calling ```create_service.py``` command.
 
## Executing service
In order to execute a service, we would need to start an instance of a context provider.

    $ python service_context.py Conf/Context-EchoAction.xml 
       ContextProvider|  Creating pool with signal handler
            EchoAction|  Parsing tree  [Context] in file: Conf/Context-EchoAction.xml
            EchoAction|  Creating an context provider
    MultiProcessTasks0|    [0] Parsing constructor arguments
    MultiProcessTasks0|  Initialising multiprocessing parent class
    MultiProcessTasks0|    [0] Creating Backend ZMQ endpoint tcp://127.0.0.1:5556
    MultiProcessTasks0|    [0] Preparing type of socket communication from arguments
            EchoAction|  Joining thread 0...
    MultiProcessTasks0|    [0] Starting service in thread [21398]
          ContextGroup|      Calling action in thread [0]
    MultiProcessTasks0|    [0] Running IPC communication on backend

The context provider generate tasked services based in context configuration. In this example we can start a __EchoAction__ service by using the command ```conf_command.py``` from the ```Tools``` section:

    $ python conf_command.py --endpoint='tcp://127.0.0.1:5557' --context_file='Conf/Context-EchoAction.xml' --service_name='context' --service_id='context001' --transaction='6FDAHH3WPRVV7FGZCRIN' --action='start'
        + Connecting endpoint [tcp://127.0.0.1:5557] in topic [context]
        + Sending message of [1436e] bytes

The ```conf_command.py``` command requires of the following parameters:

  * __Context file__: XML configuration file with tasked service information.
  * __Service name__: the context provider uses a "*context*" topic for managing contexts' configuration.  
  * __Service ID__: each context has a service ID for managing purposes
  * __Transaction__: sets a transaction identifier for managing the context and its group of services.
  * __Action__: the context actions are *start*, *stop* and *restart*.
  
This command will generate a context with identifier __6FDAHH3WPRVV7FGZCRIN__ and a unique service __EchoAction__. Any further reference to stear __EchoAction__ service would require the context identifier.  

 
## Generating multiple services
To generate skeleton environment for multiple services, prepare a service configuration XML file:

    <MetaServiceConf>
      <context_name>StateMachineSample</context_name>
      <server_ip>127.0.0.1</server_ip>
      <sub_port>5556</sub_port>
      <pub_port>5557</pub_port>
    
      <Service>
        <service_path>/path-to-services-home/</service_path>
        <task_service>Stand</task_service>
        <task_file>Stand</task_file>
        <task_class>Standing</task_class>
        <task_desc>Stand up without doing anything</task_desc>
        <service_name>state_update</service_name>
        <task_id>ts_100</task_id>
        <device_action>pass_state1</device_action>
      </Service>
      
      <Service>
        <service_path>/path-to-services-home/</service_path>
        <task_service>Walk</task_service>
        <task_file>Walker</task_file>
        <task_class>Walking</task_class>
        <task_desc>Walk along the street</task_desc>
        <service_name>state_update</service_name>
        <task_id>ts_101</task_id>
        <device_action>pass_state2</device_action>
      </Service>
    
      <Service>
        <service_path>/path-to-services-home/</service_path>
        <task_service>DrinkCoffee</task_service>
        <task_file>CoffeeDrinker</task_file>
        <task_class>Drinking</task_class>
        <task_desc>Stop and take a coffee</task_desc>
        <service_name>state_update</service_name>
        <task_id>ts_102</task_id>
        <device_action>pass_state3</device_action>
      </Service>
    
      <Service>
        <service_path>/path-to-services-home/</service_path>
        <task_service>Run</task_service>
        <task_file>Runner</task_file>
        <task_class>Running</task_class>
        <task_desc>Start running</task_desc>
        <service_name>state_update</service_name>
        <task_id>ts_103</task_id>
        <device_action>pass_state4</device_action>
      </Service>
    </MetaServiceConf>

This configuration includes information for generating skeleton code of four services. To generate the service environment execute the command:

    $ python Tools/create_service.py --xml_file=Conf/Services-StateMachine.xml

The command will generate the following file structure:

    $ ls -laR Services/
    
    Services/Run/:
    __init__.py  
    Run.py  Run.pyc
    ServiceRun.py
    
    Services/Stand/:
    __init__.py  
    ServiceStand.py
    Stand.py
    
    Services/Stand/:
    __init__.py
    ServiceStand.py
    Stand.py
    
    Services/Walk/:
    __init__.py
    ServiceWalk.py
    Walk.py

The environment is loaded by the service context command:

    $ python service_context.py Conf/Context-StateMachine.xml
    $ python conf_command.py --endpoint='tcp://127.0.0.1:5557' --context_file='Conf/Context-StateMachine.xml' --service_name='context' --service_id='context001' --transaction='5HGAHZ3WPZUI71PACRPP' --action='start'
