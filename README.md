# Context-based Task Queue
A context-based task queue implementation of for creating stand-along processes with an specific purpose while having the ability to communicate withing other processes in their or other context.

Communcication is implemented using ZMQ forward devices in a TCP/IP stack.

* __Context__: A context is a set of services typically defined by processes but also available in threads. A context is provided with a transaction identifier. The services inside a context can be selectively controlled by identifying the transaction in a context. Additionally, any context communication is generated by using messages over the *context* topic. 

* __Task service__: A task service is configured in an XML file. A service requires of an identifer, topic for publishing, an instance type and a service type (process or thread). The instance type encapsulates a specific functionality and can be loaded dynamically. In addition, services can interact among each other by using a TCP/IP based interprocess communication along a *process* topic.

* __Message__: A message is a JSON formmatted data structure for containing service ouput or input. A message is conformed by a header and a content section. Each message is generated by a service andpublished in a topic depending on the communication destination and functionality.

* __Context managing__: The services and context can communicate by using an endpoint and port. The group of services in a context can be started, stopped or restarted. In addition, services in a context can be executed in a event-based state machine by using state transitions: *on_exit*, *on_fail* and *on_start*.
* __Context managing__: The services and context can communicate by using an endpoint and port. The group of services in a context can be started, stopped or restarted. In addition, services in a context can be executed in a event-based state machine by using state transitions: *on_exit*, *on_fail* and *on_start*.

# Tutorial
## Service creation
To create a context service it is required to do the following steps:
1. Add a service directory
2. Provide a ```__init__.py```
3. Generate a ```Service[NAME].py``` stub file
4. Generate a strategy file stub
5. Update configuration ```XML``` file

In this tutorial we are using the ```create_service.py``` command that is contained in the ```Tools``` section. This command allow us to run all steps for generating a context service.

We will create a context service called __EchoAction__:

    $ python create_service.py     
        --service_path='/abs/unix/path/'
		--task_service='EchoAction' 
		--task_file='task_file_name 
		--task_class='EchoShouting' 
		--task_desc='An echo action is for shouting the time after counting 10s' 
		--context_name='EchoAction' 
		--service_name='echo_action' 
		--server_ip='127.0.0.1' 
		--sub_port='5556' 
		--pub_port='5557' 
		--task_id='ts_100' 
		--device_action='shout'

Afterwards, configuration file can be found in:

    $ ls Conf/
    Context-EchoAction.xml  ...

And the service files can be found in:

    $ ls Services/
    EchoAction  ...
    
    $ ls Services/EchoAction/
    EchoAction.py  __init__.py  ServiceEchoAction.py
    
## Service configuration
The ```create_service.py``` command requires the following parameters:
* Service configuration location
  * __Service path__ is the absolute root path where context services are located
* Service generation stub variables
  * __Service instance type__ is the type of created service as defined in task 
  service parameters as 'instance' in the configuration file.
  * __Task file name__ is for defining specific operations from task class. It will be imported from created directory and used to instance a 
  task class.
  * __Service class name__ is the name of the autogenerated task class. It should have the logic for   producing a service. It is called by the service and imported by file name.
  * __Task Description__ it is required for logging and identifying task operations.
* Service XML configuration options
  * __Context name__ is the logging context name. It is used in 'TaskLogName' in the configuration file.
  * __Service name__ defines a service name for the identifying service process messages. It is called in process configuration configuration file.
  * __Service endpoint__ states an IP address of server endpoint. It is used in 'FrontEndEndpoint' and 'BackendEndpoint' in the configuration file.
  * __Frontend port__ is used as frontend port for subscriber and back end binding ports. It is used in 'FrontEndEndpoint'
  and 'BackendBind' in the configuration file.
  * __Backend port__ is used as backend port for subscriber and front end binding ports. It is used in 'BackendEndpoint' and 'FrontBind' in the configuration file.
  * __Task ID__ defines a task service ID identifier. It is used as parameter 'id' in 'TaskService' label in the configuration file.
  * __Device action__ is the task device action used for message identification. It is called as parameter 'device_action' of the content configuration of the task service in the configuration file.
  
All described parameters are required when calling ```create_service.py``` command.
 
## Executing service
In order to execute a service, it is requried to start a context provider. To start, the context provider requires to be initiated.

    $ python service_context.py Conf/Context-EchoAction.xml 
       ContextProvider|  Creating pool with signal handler
            EchoAction|  Parsing tree  [Context] in file: Conf/Context-EchoAction.xml
            EchoAction|  Creating an context provider
    MultiProcessTasks0|    [0] Parsing constructor arguments
    MultiProcessTasks0|  Initialising multiprocessing parent class
    MultiProcessTasks0|    [0] Creating Backend ZMQ endpoint tcp://127.0.0.1:5556
    MultiProcessTasks0|    [0] Preparing type of socket communication from arguments
            EchoAction|  Joining thread 0...
    MultiProcessTasks0|    [0] Starting service in thread [21398]
          ContextGroup|      Calling action in thread [0]
    MultiProcessTasks0|    [0] Running IPC communication on backend

The context provider generate tasked services based in context configuration. In this example we can start a __EchoAction__ service by using the command ```conf_command.py``` from the ```Tools``` section:

    $ python conf_command.py --endpoint='tcp://127.0.0.1:5557' --context_file='Conf/Context-EchoAction.xml' --service_name='context' --service_id='context001' --transaction='6FDAHH3WPRVV7FGZCRIN' --action='start'
        + Connecting endpoint [tcp://127.0.0.1:5557] in topic [context]
        + Sending message of [1436e] bytes

The ```conf_command.py``` command requires of the following parameters:

  * __Context file__: XML configuration file with tasked service information.
  * __Service name__: the context provider uses a "*context*" topic for stearing configuration.  
  * __Service ID__: each context has a service ID for managing purposes
  * __Transaction__: sets a transaction identifier for managing the context and its group of services.
  * __Action__: the context actions are *start*, *stop* and *restart*.
  
This command will generate a context with identifier __6FDAHH3WPRVV7FGZCRIN__ and a unique service __EchoAction__. Any further reference to stear __EchoAction__ service would require the context identifier.  